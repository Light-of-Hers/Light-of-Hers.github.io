<!DOCTYPE html><html lang="en" theme-mode="light"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>C++中柯里化(curry)与偏应用(partial)的实现 | Renze Chen (陈仁泽)</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
  font-family: 'Fira Code';
  src: local('Fira Code'), url('/font/FiraCode-Regular.ttf');
}
@font-face {
  font-family: 'Monaco';
  src: local('Monaco'), url('/font/Monaco.ttf');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/imgs/bk-dark-0.png');
 --light-background: url('/imgs/bk-light-5.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Blogs</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>C++中柯里化(curry)与偏应用(partial)的实现</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2020-01-17T05:22:00.000Z" id="date"> 2020-01-17</time></div></span><br><span>Blog Link: <div class="control"> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/103208520">[site]</a></div></span></div></div><hr><div id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>回家的时候在火车上草草看了下《JS函数式编程指南》，对Ramda库中curry和partial的实现略感兴趣，加之不久前，在完成C++期末大作业（<a href="https://link.zhihu.com/?target=https://github.com/Light-of-Hers/python-like-list">实现一个类似python中的list的C++泛型容器</a>）的过程中，深入学习了一下C++模板元编程的技术，因此便想用泛型编程技术实现C++中的curry和partial函数。</p>
<p>对于柯里化和偏应用不太了解的，可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30097211/answer/46785556">@罗宸的这个回答</a>，在此不多赘述。</p>
<hr>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="curry的实现思路"><a href="#curry的实现思路" class="headerlink" title="curry的实现思路"></a>curry的实现思路</h3><p>以<code>int add(int a, int b) {return a + b;}</code>为例，该函数柯里化后得到的函数对象<code>c_add</code>接收一个<code>int</code>参数a，返回一个函数对象，该对象保存之前传入的<code>int</code>参数a，接收一个<code>int</code>参数b，返回<code>a + b</code>的值。</p>
<p>这样看来柯里化后的函数对象F必须都保存调用时传入的参数，并且能将当前保存的所有参数传递给调用后返回的函数对象。</p>
<p>可以有两种实现思路：</p>
<ul>
<li><p>采用某种泛型数据结构（如<code>std::tuple</code>）保存积累至今的参数，并在传入最后一个参数的时候用某种方式一次性将所有参数传递给原函数（如<code>std::apply</code>）。这种方法比较容易想到。  </p>
</li>
<li><p>还有一种方法参见<a href="https://link.zhihu.com/?target=https://sighingnow.github.io/%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25AD%25E8%25A8%2580/cpp_currying_partial_application.html">何涛的这篇博客</a>。其基本思想是保存之前的函数对象，传入最后一个参数后逐层传递参数（最高层N将最后一个参数传递给下一层N-1，N-1将得到的参数和自己保存的参数传递给下一层N-2），在最后一层调用柯里化之前的函数。实现上会更漂亮些，但性能上感觉不如前者。可以用下面的JS伪代码表现：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">curry</span> = (<span class="hljs-params">f</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> {<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">curry</span>(<span class="hljs-title function_">partial_first_arg</span>(f, arg));<br>  }<br>}<br></code></pre></td></tr></table></figure>

<h3 id="partial的实现思路"><a href="#partial的实现思路" class="headerlink" title="partial的实现思路"></a>partial的实现思路</h3><p>偏应用的实现就比较直观，其实现思路也有两种：</p>
<ul>
<li><p>比较直观的方法：保存传入的参数，在被调用时连同传入的参数一起传给原函数。  </p>
</li>
<li><p>也是<a href="https://link.zhihu.com/?target=https://sighingnow.github.io/%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25AD%25E8%25A8%2580/cpp_currying_partial_application.html">何涛博客</a>中提到的方法，基本思想可以用下面JS伪码表述：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">partial</span> = (<span class="hljs-params">f, arg, ...args</span>) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">partial</span>(<span class="hljs-title function_">partial_first_arg</span>(f, arg), ...args);<br>}<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="实现坑点"><a href="#实现坑点" class="headerlink" title="实现坑点"></a>实现坑点</h2><p>关于curry/partial的C++实现，有不少先例，如<a href="https://link.zhihu.com/?target=https://sighingnow.github.io/%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25AD%25E8%25A8%2580/cpp_currying_partial_application.html">何涛的一篇博客</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52715274">@Khellendros的一篇文章</a>、<a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/152005/how-can-currying-be-done-in-c">stackoverflow上的一个问题</a>等，但多多少少有一些难以忽视的漏洞，包括但不限于：</p>
<ul>
<li>采用右值引用结合<code>std::forward</code>来转发函数参数，如Khellendros的curry实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A &amp;&amp;... args)</span> <span class="hljs-type">const</span> </span>{<br>    <span class="hljs-keyword">auto</span> cache2 = std::<span class="hljs-built_in">tuple_cat</span>(_cache, std::forward_as_tuple(args...));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">CurriedFunction</span>&lt;F, i - <span class="hljs-number">1</span>, <span class="hljs-keyword">decltype</span>(cache2)&gt;(_fn, std::<span class="hljs-built_in">move</span>(cache2));<br>}<br></code></pre></td></tr></table></figure>

<p>这样会将所有传入的左值引用都保存为引用，而不是根据原函数的参数类型保存为值/引用，在许多情况下会导致悬垂引用问题。如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a + b;<br>}<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>    <span class="hljs-keyword">return</span> Reimuda::<span class="hljs-built_in">curry</span>&lt;<span class="hljs-number">2</span>&gt;(add)(x);<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">auto</span> f1 = <span class="hljs-built_in">inc</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> f2 = <span class="hljs-built_in">inc</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">auto</span> f3 = <span class="hljs-built_in">inc</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">auto</span> f4 = <span class="hljs-built_in">inc</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">auto</span> f5 = <span class="hljs-built_in">inc</span>(<span class="hljs-number">5</span>);<br>    std::cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl;<br>}<br></code></pre></td></tr></table></figure>

<p>会输出奇怪的数（反正不是2），因为<code>inc</code>中的<code>curry(add)</code>接收<code>x</code>后保存的是<code>x</code>的引用而不是值，之后对<code>inc</code>的调用会覆写原引用指向的栈上的位置。</p>
<ul>
<li><p>采用引用保存原函数。和前例一样也会出现悬垂引用问题。一般对于函数对象而言保存值是最好的，如果需要保存引用可以用<code>std::ref</code>显式包装。</p>
</li>
<li><p>对于函数和保存的参数的可拷贝性缺乏考量。</p>
</li>
<li><p>没有按原函数的参数类型要求严格地按值/引用保存传入的参数。这点是1.的延伸。</p>
</li>
</ul>
<p>……</p>
<p>上述问题主要都是C++的内存管理模式导致的。和ML、Lisp等大多数带函数式编程特性的语言不同，C++没有GC，这就导致了实现curry&amp;partial的过程中，在涉及值/引用和拷贝/移动时需要更细致的考察（用Rust的话编译器会帮你考察……）。</p>
<hr>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="函数签名的萃取"><a href="#函数签名的萃取" class="headerlink" title="函数签名的萃取"></a>函数签名的萃取</h3><p>前面的部分说过，想要在C++中实现一个行为较为正确的curry&amp;partial，必须显式地解析参数类型，根据参数类型来决定保存传入的参数的值还是引用。因此需要一些TMP技巧来萃取函数对象的签名。这部分内容可以参见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102240099">这篇文章</a>，这里仅给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> __detail {<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...As&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__function_traits_base</span> {<br>    <span class="hljs-keyword">using</span> function_type = std::function&lt;<span class="hljs-built_in">R</span>(As...)&gt;;<br><br>    <span class="hljs-keyword">using</span> result_type = R;<br><br>    <span class="hljs-keyword">using</span> argument_types = std::tuple&lt;As...&gt;;<br>};<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__function_traits</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__function_traits</span>&lt;std::reference_wrapper&lt;F&gt;&gt; : <span class="hljs-keyword">public</span> __function_traits&lt;F&gt; {};<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...As&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__function_traits</span>&lt;<span class="hljs-built_in">R</span>(*)(As...)&gt; : <span class="hljs-keyword">public</span> __function_traits_base&lt;R, As...&gt; {};<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> ...As&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__function_traits</span>&lt;<span class="hljs-built_in">R</span>(C::*)(As...)&gt; : <span class="hljs-keyword">public</span> __function_traits_base&lt;R, As...&gt; {};<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> ...As&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__function_traits</span>&lt;<span class="hljs-built_in">R</span>(C::*)(As...) <span class="hljs-type">const</span>&gt; : <span class="hljs-keyword">public</span> __function_traits_base&lt;R, As...&gt; {};<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__function_traits</span> : <span class="hljs-keyword">public</span> __function_traits&lt;<span class="hljs-keyword">decltype</span>(&amp;F::<span class="hljs-built_in">operator</span>())&gt; {};<br><br>}<br><br><span class="hljs-keyword">namespace</span> fp {<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">function_traits</span> : <span class="hljs-keyword">public</span> __detail::__function_traits&lt;std::<span class="hljs-type">decay_t</span>&lt;F&gt;&gt; {};<br><br>}<br></code></pre></td></tr></table></figure>

<h3 id="curry的实现"><a href="#curry的实现" class="headerlink" title="curry的实现"></a>curry的实现</h3><p>采用第一种思路实现。</p>
<p>首先定义一个可以缓存参数的cacher作为curry的返回值。模板中的<code>TA</code>表示”Tuple of Args”，即保存的参数元组的类型，<code>A</code>和<code>As</code>表示之后还剩下的参数类型。cacher接收一个参数，用其扩展<code>cached_args</code>，将扩展后的<code>cached_args</code>传给一个新的cacher，并返回新cacher。</p>
<p>其中注意<code>cached_args</code>和<code>f</code>可能不可拷贝，因此用<code>__copy_or_move</code>包装，视情况将其拷贝/移动给新的cacher。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__curry_cacher</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> TA, <span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> ...As&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__curry_cacher</span>&lt;F, TA, std::tuple&lt;A, As...&gt;&gt; {<br>    F f;<br>    TA cached_args;<br><span class="hljs-keyword">public</span>:<br>    __curry_cacher(F f, TA args) : <span class="hljs-built_in">f</span>(std::<span class="hljs-built_in">move</span>(f)), <span class="hljs-built_in">cached_args</span>(std::<span class="hljs-built_in">move</span>(args)) {}<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A arg)</span> </span>{<br>        <span class="hljs-keyword">auto</span> new_cached_args = std::<span class="hljs-built_in">tuple_cat</span>(<br>                __copy_or_move(cached_args),<br>                std::<span class="hljs-built_in">tuple</span>&lt;A&gt;(std::forward&lt;A&gt;(arg)));<br>        <span class="hljs-keyword">return</span> __curry_cacher&lt;F,<br>                <span class="hljs-keyword">decltype</span>(new_cached_args),<br>                std::tuple&lt;As...&gt;&gt;(__copy_or_move(f), std::<span class="hljs-built_in">move</span>(new_cached_args));<br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>其中<code>__copy_or_move</code>的实现如下（虽然比较trivial，但还是贴出来吧）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">auto</span> __copy_or_move(<span class="hljs-type">const</span> T &amp;t) -&gt; T {<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_copy_constructible_v&lt;T&gt;)</span> </span>{<br>        <span class="hljs-keyword">return</span> t;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">const_cast</span>&lt;T &amp;&gt;(t));<br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>当剩余的参数只有一个的时候，调用cacher将直接调用保存的原函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> TA, <span class="hljs-keyword">typename</span> A&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__curry_cacher</span>&lt;F, TA, std::tuple&lt;A&gt;&gt; {<br>    F f;<br>    TA cached_args;<br><span class="hljs-keyword">public</span>:<br>    __curry_cacher(F f, TA args) : <span class="hljs-built_in">f</span>(std::<span class="hljs-built_in">move</span>(f)), <span class="hljs-built_in">cached_args</span>(std::<span class="hljs-built_in">move</span>(args)) {}<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A arg)</span> </span>{<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">apply</span>(f, std::<span class="hljs-built_in">tuple_cat</span>(<br>                __copy_or_move(cached_args),<br>                std::<span class="hljs-built_in">tuple</span>&lt;A&gt;(std::forward&lt;A&gt;(arg))));<br>    }<br>};<br></code></pre></td></tr></table></figure>

<p>实现完cacher后，就可以实现curry了。先将参数类型的元组萃取出来，之后返回一个没有缓存参数的cacher。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">curry</span><span class="hljs-params">(F f)</span> </span>{<br>    <span class="hljs-keyword">using</span> arg_types = <span class="hljs-keyword">typename</span> function_traits&lt;F&gt;::argument_types;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::tuple_size_v&lt;arg_types&gt; &lt; <span class="hljs-number">2</span>)</span> </span>{<br>        <span class="hljs-keyword">return</span> f;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> __detail::__curry_cacher&lt;F, std::tuple&lt;&gt;, arg_types&gt;<br>                (std::<span class="hljs-built_in">move</span>(f), std::tuple&lt;&gt;());<br>    }<br>}<br></code></pre></td></tr></table></figure>

<h3 id="partial的实现"><a href="#partial的实现" class="headerlink" title="partial的实现"></a>partial的实现</h3><p>也采用第一种思路实现partial。</p>
<p>先定义一个cacher来缓存参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__partial_cacher</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> TA, <span class="hljs-keyword">typename</span> ...As&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__partial_cacher</span>&lt;F, TA, std::tuple&lt;As...&gt;&gt; {<br>    F f;<br>    TA cached_args;<br><span class="hljs-keyword">public</span>:<br>    __partial_cacher(F f, TA args) : <span class="hljs-built_in">f</span>(std::<span class="hljs-built_in">move</span>(f)), <span class="hljs-built_in">cached_args</span>(std::<span class="hljs-built_in">move</span>(args)) {}<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(As... args)</span> </span>{<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">apply</span>(f, std::<span class="hljs-built_in">tuple_cat</span>(<br>                __copy_or_move(cached_args),<br>                std::<span class="hljs-built_in">tuple</span>&lt;As...&gt;(std::forward&lt;As&gt;(args)...)));<br>    }<br>};<br></code></pre></td></tr></table></figure>

<p>之后实现partial。同样是先萃取函数签名，在返回一个缓存着接收到的参数的cacher。注意cacher模板的第三个参数是接下来还要接收的函数参数类型，因此需要用函数签名中的参数类型刨去前面已经接收的参数类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> ...As&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">partial</span><span class="hljs-params">(F f, As &amp;&amp;...args)</span> </span>{<br>    <span class="hljs-keyword">using</span> arg_types = <span class="hljs-keyword">typename</span> function_traits&lt;F&gt;::argument_types;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-keyword">sizeof</span>...(As) &lt;= std::tuple_size_v&lt;arg_types&gt;, <span class="hljs-string">"Too many arguments"</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>...(As) == <span class="hljs-number">0</span>)</span> </span>{<br>        <span class="hljs-keyword">return</span> f;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (<span class="hljs-keyword">sizeof</span>...(As) == std::tuple_size_v&lt;arg_types&gt;) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(std::forward&lt;As&gt;(args)...);<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> __detail::__partial_cacher&lt;F, std::tuple&lt;As...&gt;, __detail::<span class="hljs-type">__tuple_drop_n_t</span>&lt;<span class="hljs-keyword">sizeof</span>...(As), arg_types&gt;&gt;<br>                (std::<span class="hljs-built_in">move</span>(f), std::<span class="hljs-built_in">tuple</span>&lt;As...&gt;(std::forward&lt;As&gt;(args)...));<br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>其中<code>__tuple_drop_n_t&lt;N, T&gt;</code>用于丢弃元组<code>T</code>的前<code>N</code>个类型，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> I, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">struct</span> __tuple_drop_n;<br><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> I, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">__tuple_drop_n_t</span> = <span class="hljs-keyword">typename</span> __tuple_drop_n&lt;I, T&gt;::type;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__tuple_drop_n</span>&lt;<span class="hljs-number">0</span>, std::tuple&lt;Ts...&gt;&gt; {<br>    <span class="hljs-keyword">using</span> type = std::tuple&lt;Ts...&gt;;<br>};<br><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> I, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Ts&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__tuple_drop_n</span>&lt;I, std::tuple&lt;T, Ts...&gt;, std::<span class="hljs-type">enable_if_t</span>&lt;(I &gt; <span class="hljs-number">0</span>)&gt;&gt; {<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">__tuple_drop_n_t</span>&lt;I - <span class="hljs-number">1</span>, std::tuple&lt;Ts...&gt;&gt;;<br>};<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><h3 id="curry的测试"><a href="#curry的测试" class="headerlink" title="curry的测试"></a>curry的测试</h3><h3 id="call-by-value"><a href="#call-by-value" class="headerlink" title="call-by-value"></a>call-by-value</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d) {<br>        <span class="hljs-keyword">return</span> a + b + c + d;<br>    };<br>    <span class="hljs-keyword">auto</span> c_add = <span class="hljs-built_in">curry</span>(add);<br>    std::cout &lt;&lt; <span class="hljs-built_in">c_add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 10</span><br>    <span class="hljs-keyword">auto</span> c_add_1 = <span class="hljs-built_in">c_add</span>(<span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-built_in">c_add_1</span>(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>

<h3 id="call-by-reference"><a href="#call-by-reference" class="headerlink" title="call-by-reference"></a>call-by-reference</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> genso_concat = [](std::string &amp;s) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">curry</span>([&amp;](std::string &amp;a, <span class="hljs-type">const</span> std::string &amp;b) {<br>            <span class="hljs-keyword">auto</span> tmp = a;<br>            a += <span class="hljs-string">" "</span> + b + <span class="hljs-string">" "</span> + s;<br>            s += <span class="hljs-string">" "</span> + b + <span class="hljs-string">" "</span> + tmp;<br>        });<br>    };<br>    <span class="hljs-keyword">auto</span> s1 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"Reimu"</span>), s2 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"Marisa"</span>);<br>    <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">genso_concat</span>(s1);<br>    <span class="hljs-keyword">auto</span> ff = <span class="hljs-built_in">f</span>(s2);<br>    <span class="hljs-built_in">ff</span>(<span class="hljs-string">"love"</span>);<br>    std::cout &lt;&lt; s1 &lt;&lt; std::endl; <span class="hljs-comment">// Reimu love Marisa</span><br>    std::cout &lt;&lt; s2 &lt;&lt; std::endl; <span class="hljs-comment">// Marisa love Reimu</span><br></code></pre></td></tr></table></figure>

<h3 id="closure"><a href="#closure" class="headerlink" title="closure?"></a>closure?</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> greater_than = [](<span class="hljs-type">int</span> x) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">curry</span>([](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) { <span class="hljs-keyword">return</span> a &lt; b; })(x);<br>    };<br>    <span class="hljs-keyword">auto</span> gt_0 = <span class="hljs-built_in">greater_than</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> gt_1 = <span class="hljs-built_in">greater_than</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> gt_2 = <span class="hljs-built_in">greater_than</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">auto</span> gt_3 = <span class="hljs-built_in">greater_than</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; std::boolalpha;<br>    std::cout &lt;&lt; <span class="hljs-built_in">gt_0</span>(<span class="hljs-number">-1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// false</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">gt_0</span>(<span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// false</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">gt_0</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h3 id="non-copyable-function"><a href="#non-copyable-function" class="headerlink" title="non-copyable-function"></a>non-copyable-function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniF</span> {<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uip;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">UniF</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : uip(new int{</span>x}) {}<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a = *uip += b;<br>    }<br>};<br>{<br>    UniF uf{<span class="hljs-number">1</span>};<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">curry</span>(std::<span class="hljs-built_in">move</span>(uf));<br>    <span class="hljs-keyword">auto</span> x_f = std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">f</span>(x));<br>    std::cout &lt;&lt; <span class="hljs-built_in">x_f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 2</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">x_f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">x_f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>}<br>{<br>    UniF uf{<span class="hljs-number">1</span>};<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">curry</span>(std::<span class="hljs-built_in">ref</span>(uf));<br>    std::cout &lt;&lt; <span class="hljs-built_in">f</span>(x)(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 2</span><br>    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">auto</span> x_f = <span class="hljs-built_in">f</span>(x);<br>    std::cout &lt;&lt; <span class="hljs-built_in">x_f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">x_f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>}<br></code></pre></td></tr></table></figure>

<h3 id="partial的测试"><a href="#partial的测试" class="headerlink" title="partial的测试"></a>partial的测试</h3><h3 id="call-by-value-1"><a href="#call-by-value-1" class="headerlink" title="call-by-value"></a>call-by-value</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> gt_0 = <span class="hljs-built_in">partial</span>(std::less&lt;<span class="hljs-type">int</span>&gt;{}, <span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; std::boolalpha;<br>    std::cout &lt;&lt; <span class="hljs-built_in">gt_0</span>(<span class="hljs-number">-1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// false</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">gt_0</span>(<span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// false</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">gt_0</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h3 id="call-by-reference-1"><a href="#call-by-reference-1" class="headerlink" title="call-by-reference"></a>call-by-reference</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pair_assign = [](<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b, <span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb) -&gt; <span class="hljs-type">void</span> { a = aa, b = bb; };<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> assign_a_b = <span class="hljs-built_in">partial</span>(pair_assign, a, b);<br>    <span class="hljs-built_in">assign_a_b</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; std::endl; <span class="hljs-comment">// 1, 2</span><br></code></pre></td></tr></table></figure>

<h3 id="non-copyable-function-1"><a href="#non-copyable-function-1" class="headerlink" title="non-copyable-function"></a>non-copyable-function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uip{<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>{<span class="hljs-number">0</span>}};<br>    <span class="hljs-keyword">auto</span> uf = [p = std::<span class="hljs-built_in">move</span>(uip)](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) {<br>        <span class="hljs-keyword">return</span> *p += a + b;<br>    };<br>    {<br>        <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">partial</span>(std::<span class="hljs-built_in">ref</span>(uf), <span class="hljs-number">1</span>);<br>        std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 2</span><br>        std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>        std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 6</span><br>    }<br>    {<br>        <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">partial</span>(std::<span class="hljs-built_in">move</span>(uf), <span class="hljs-number">1</span>);<br>        std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 8</span><br>        std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 10</span><br>        std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 12</span><br>    }<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul>
<li>传给curry&amp;partial的必须是类型确定的函数，也就是说函数模板和重载的函数（含有默认形参的函数也算）不能直接传入。对于函数模板，需要实例化后传入；对于重载的函数，需要显式转换到确定的类型才能传入。</li>
<li>curry&amp;partial默认传入函数的拷贝，如果想传入函数引用可以用<code>std::ref</code>/<code>std::cref</code>进行包装后将引用间接传入。如果传入的函数对象是不可拷贝的，可以选择用<code>std::ref</code>间接传引用或者用<code>std::move</code>转让所有权。</li>
<li>需要C++17标准支持（主要是<code>constexpr if</code>特性，毕竟多分支模板匹配写起来还是蛮令人不爽的……）。</li>
</ul>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>自己在PKU-CECA里搞的东西基本和PL或C++没有什么关系（硬要扯上关系的话，TVM的Relay的研究和PL有点关系？或者写CUDA之类的和C++有点关系？），所以这两天搞这种无用的玩意纯属摸鱼行为……不过，虽然无用，但造轮子还是蛮爽的。</p>
<p>附上代码链接：<a href="https://link.zhihu.com/?target=https://github.com/Light-of-Hers/Cpp-curry-partial-and-other-FP-combinators">https://github.com/Light-of-Hers/Cpp-curry-partial-and-other-FP-combinators</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2020/01/21/C++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(ADT)%E5%8F%8A%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AD%89%E6%93%8D%E4%BD%9C%EF%BC%9A%E4%BB%A5%E7%BC%96%E8%AF%91%E6%9C%9FAVL%E6%A0%91%E4%B8%BA%E4%BE%8B/">← Next C++模板元编程中的代数数据类型(ADT)及模式匹配等操作：以编译期AVL树为例</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2020/01/11/C++%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/">C++获取函数的参数和返回值类型 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a target="_blank" rel="noopener" href="https://prts.wiki/w/%E6%96%87%E4%BB%B6:%E6%A8%A1%E7%BB%84_%E5%8C%BB%E4%B8%8D%E8%87%AA%E6%B2%BB.png" id="logo"><img src="/imgs/avatar.png" alt="Logo"></a><h1 id="Dr"><a href="/">Renze Chen</a></h1><div id="description"><p>陈仁泽</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/Light-of-Hers"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://www.zhihu.com/people/yi-guang-99-48"><i class="fab fa-zhihu" alt="Zhihu"></i></a><a class="social" target="_blank" rel="noopener" href="https://orcid.org/0000-0001-5938-7965"><i class="fab fa-orcid" alt="ORCID"></i></a><a class="social" target="_blank" rel="noopener" href="https://dblp.org/pid/260/5910"><i class="iconfont icon-dblp" alt="DBLP"></i></a><a class="social" href="mailto:crz@pku.edu.cn"><i class="fa fa-envelope" alt="E-Mail"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#curry%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.</span> <span class="toc-text">curry的实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.</span> <span class="toc-text">partial的实现思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9D%91%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">实现坑点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">4.</span> <span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E7%9A%84%E8%90%83%E5%8F%96"><span class="toc-number">4.1.</span> <span class="toc-text">函数签名的萃取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#curry%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">curry的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">partial的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-number">5.</span> <span class="toc-text">简单测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#curry%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">5.1.</span> <span class="toc-text">curry的测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-by-value"><span class="toc-number">5.2.</span> <span class="toc-text">call-by-value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-by-reference"><span class="toc-number">5.3.</span> <span class="toc-text">call-by-reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#closure"><span class="toc-number">5.4.</span> <span class="toc-text">closure?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-copyable-function"><span class="toc-number">5.5.</span> <span class="toc-text">non-copyable-function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partial%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">5.6.</span> <span class="toc-text">partial的测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-by-value-1"><span class="toc-number">5.7.</span> <span class="toc-text">call-by-value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-by-reference-1"><span class="toc-number">5.8.</span> <span class="toc-text">call-by-reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-copyable-function-1"><span class="toc-number">5.9.</span> <span class="toc-text">non-copyable-function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F"><span class="toc-number">6.</span> <span class="toc-text">使用注意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">7.</span> <span class="toc-text">后记</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main></body></html>